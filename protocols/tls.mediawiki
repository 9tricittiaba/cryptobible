

To '''encrypt communications between endpoints''', several protocols exist. The most populars being '''TLS''', '''SSH''' and '''IPSEC'''. Each usually being used for different purposes. Yet, many developers will often feel the need to re-invent the wheel and create their own "proprietary" protocol. You've heard the saying "don't roll your own crypto", so you know you should use TLS. If you're not using TLS because you have an excellent reason not to use TLS, you are allowed to consider the <a href="http://noiseprotocol.org/">Noise protocol framework</a>, but keep in mind that even Noise requires you to understand what you're doing.

== TLS ==

While TLS is usually used between browsers and webservers, there are no limitations as to how one can use TLS and to what kind of endpoints are able to use TLS to protect their communications. Because of this initial setting though, TLS is commonly encountered as a protocol that '''authenticates the server only''' and does not care about the client (perhaps the client authenticates later via a password in the application layer). Yet, this does not mean that TLS is limited to this configuration and client authentication (via certificates) as part of the protocol is totally possible.

Note that TLS is sometimes seen deeply integrated with another kind of protocol. For example the QUIC protocol (sometimes refered to as TCP 2.0) has encryption by default thanks to TLS.

=== What Versions should be supported? ===

The design of SSL/TLS has had many broken versions in the past. For this reason, nobody uses SSL anymore (which ended at version 3) and more secure versions of TLS (1.2 and 1.3) are pushed.

<table>
<thead>
<tr class="header">
<th>Version</th>
<th>Secure</th>
<th>Vulnerabilities</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SSL 2</td>
<td>no</td>
<td>TKTK</td>
</tr>
<tr class="even">
<td>SSL 3</td>
<td>no</td>
<td>POODLE, RC4NOMORE</td>
</tr>
<tr class="odd">
<td>TLS 1.0</td>
<td>no</td>
<td>BEAST, RC4NOMORE</td>
</tr>
<tr class="even">
<td>TLS 1.1</td>
<td>yes</td>
<td>/</td>
</tr>
<tr class="odd">
<td>TLS 1.2</td>
<td>yes</td>
<td>/</td>
</tr>
<tr class="even">
<td>TLS 1.3</td>
<td>yes</td>
<td>/</td>
</tr>
</tbody>
</table>

'''Ideally, only TLS 1.1, 1.2 and 1.3 should be supported'''. Hyper ideally, only the last version (TLS 1.3) should be supported.

=== Can older versions be supported? ===

Unfortunately, many clients continue to use older versions and it is sometimes needed to continue to support them. In particular, it sometimes comes to the point where companies take the decision to support SSL 3 and TLS 1.0.

Eventhough Beast broke the protocol, there exists ways to mitigate them on the client-side (which most modern browsers implement): https://cryptologie.net/article/413/beast-an-explanation-of-the-cbc-attack-on-tls/ .With that in mind, '''supporting TLS 1.0 is possible, but not recommended'''.

'''But can you support older version nonetheless?'''

POODLE and BEAST are attacks that usually imply a browser-based client. This is because the attack requires several things:

# you need to execute code on the client in order to emite specific packets
# the decryption is possible because you know most of the bytes in a client's packet. This is usually true for browsers because we know what kind of requests they are making and we only care about stealing a cookie or a secret that is repeteadly included in the client messages.

For this reason, '''most of the non-browser-webserver scenarios might not be vulnerable to these attacks'''. Nonetheless attacks only get better and one should not rely on a specific scenario to mitigate a powerful attack.


# <a href="https://blog.qualys.com/ssllabs/2013/09/10/is-beast-still-a-threat">is BEAST still a threat</a>
# SSL3 ~ ok if you can fight downgrade attacks (DROWN) there is an RFC for that: https://tools.ietf.org/html/rfc7507

Note that some regulations (like the <a href="https://www.comodo.com/e-commerce/ssl-certificates/tls-1-deprecation.php)">PCI</a> might be more strict on what versions you are allowed to use.

=== What Cipher Suites are secure? ===

A perfect whitelist of cipher suites would include combinations of the following algorithms:

# key exchange: ECDH
# signature: RSA or ECDSA
# authenticated encryption: AES-128-GCM, AES-256-GCM or Chacha20-Poly1305
# hash: SHA-256, SHA-384 or SHA-521

For example the following cipher suite would be a good candidate <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>.
Note that OpenSSL is stupid and has renamed all the ciphersuites. Fortunately the OWASP has a <a href="https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet=Table_of_the_ciphers_.28and_their_priority_from_high_.281.29_to_low_.28e.g._19.29.29">translation table</a>.

Nonetheless, this doesn't mean that other algorithms are not secure.

'''RSA key exchange''' has had a lot of issues with the Bleichenbacher attack. Implementations are expected not to leak any information about the correctness of the decryption, but most of them still fail this test. Hence this mode should be avoided just because attacks against it are really practical and hard to mitigate correctly. In addition, this key exchange does not provide forward secrecy and is one of the reason why it has been removed from TLS 1.3.

'''DH key exchange''' has had <a href="https://eprint.iacr.org/2016/644) (LOGJAM) with bad groups in the past. That is to say if the server use secure groups and renew there should be no issues. You can use the [test_DHparams](https://github.com/mimoo/test_DHparams">issues</a> tool to verify if a server's Diffie-Hellman parameters are fine.

'''DSA''' ?

'''AES-CBC''' is wrongly implemented in TLS and has lead to several practical attacks. POODLE on SSL 3, BEAST on TLS 1.0 and padding oracles on all versions. That is to say, there exist client-side mitigations for BEAST (none server-side) and padding oracles on CBC should not be possible if the implementation does not leak information about the correctness of the decryption. That is, implementations have been found to repeatidly make mistakes there (Lucky Thirteen has been re-discovered many times) and thus AES-CBC should be quickly deprecated.

'''3DES''' also called DES-CBC3 or DES-EDE (for Encryption-Decryption-Encryption) was pointed out by the <a href="https://www.cryptologie.net/article/373/tldr-of-the-sweet32-attack-on-the-practical-in-security-of-64-bit-block-ciphers/) attack as insecure (along with other 64-bit ciphers">sweet32</a>. Although the attack remains highly impractical and hence the algorithm can be used but should be scheduled for deprecation.

'''RC4''' ?

TLS can support many more ciphers through various extensions. It would be too long for us to list why each of them should not be included. Wikipedia has [a useful table](https://en.wikipedia.org/wiki/Transport_Layer_Security=Cipher
) that shows what ciphers are deemed secure or not.

In addition, Mozilla's <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">SSL config generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/?hsts=no) and [Server-side TLS wiki</a> can be used to guide you through generating sane TLS configurations.

Without a server's source code, the most straight forward way to assess its configuration is to scan it via tools. Check the <a href="">scanning a server</a> section.

Note that sometimes, you want to support older clients that do not have better options than RC4 or DSA or etc... In the end, the server is always the one who chooses and can choose the best option provided by the client. The only danger is having the server offer really bad key exchange mechanisms which would allow a MITM attacker to hide the real list of the client to pretend that the client only support weak ciphers (ciphersuite downgrade?). See LOGJAM and FREAK

<blockquote> Similarly, GFEs will prefer RC4 over AES-CBC only for low protocol versions (SSLv3/TLSv1) because negotiating these versions with AES-CBC would leave the clients vulnerable to POODLE. </blockquote>
# https://sites.google.com/site/bughunteruniversity/nonvuln/commonly-reported-ssl-tls-vulnerabilities

=== 0-RTT ===

TLS 1.3 introduces a new concept called "0-RTT" or "early data" which allows clients to send encrypted requests to servers during their very first flight of messages. Because of the design of this feature, these messages are not forward-secure and are '''replayable'''. This is a problem if such requests can mutate the state of the server.

TLS 1.3 client that enable this feature are supposed to maintain a whitelist of requests that are safe to send as early data.

TLS 1.3 servers that enable this feature should also maintain such a whitelist ('''REALLY?''')

'''Ideally, 0-RTT should not be enabled on either side of the connection'''.

=== How to assess certificates? ===

# a server is usually authenticated via its certificate
# the certificate contains a public key (see keylength.com)
# the certificate also contains a signature from an authority that you trust
# that's PKI
# otherwise you need to trust the certificate (certificate pinning)
# these certificates are usually stores as <code>.pem</code> files
# <a href="">x509 vs asn.1 vs DER vs pem</a>
# note that x509 parsers are often riddled with bugs (parsing is hard)
    - so might want to look in there for wrong parsing, but it's hard because you need to understand how to parse DER
    - fuzz! you can use frankencerts
    - boringSSL and others might have more corpus
# you can easily analyze a certificate with:

<pre><code>
openssl x509 -in yourcert.pem -noout -text
</code></pre>

<a href="">check more openssl handies here</a>

# how to store a certificate?
# unicornator helps you looking at certificates as well
# <a href="https://www.cryptologie.net/article/374/common-x509-certificate-validationcreation-pitfalls"></a>

=== How to scan a server? ===

# you scan easily TLS with tools like 
    - testssl.sh
    - sslyzer
    - https://github.com/mozilla/tls-observatory
    - https://github.com/mozilla/cipherscan
    - https://www.bolet.org/TestSSLServer/

# careful though, they might give out results without much explanations

# online scanners:
    - https://www.ssllabs.com/ssltest/

# openssl has a limited client

<pre><code>
openssl s_client -connect google.com:443
</code></pre>

# socat can usually do some stuff as well:

<pre><code>
socat 
</code></pre>

=== how to test clients? ===

# https://badssl.com/ 

=== How to configure a TLS server correctly? ===

# https://mozilla.github.io/server-side-tls/ssl-config-generator/?hsts=no
# https://wiki.mozilla.org/Security/Server_Side_TLS

Go: https://github.com/gtank/cryptopasta/blob/master/tls_test.go

=== Tools ===

# https://github.com/RUB-NDS/TLS-Attacker  
# https://github.com/hannob/selftls
# TKTK
# https://github.com/FiloSottile/mkcert ?

=== code review of a TLS implementation ===

# very few people can write a full TLS stack securely
# do not review a TLS implementation unless you have to, it takes more than this guide to do it
# using one of the library advised in the next section is better
# but if you really have to, here are a few pointers:

# x509 parsing
# incorrect state machine
# vaudenay -> padding errors
# lucky thirteen in TLS 1. -> constant time CBC MAC verification
# RSA bleichenbacher in TLS 1. and TLS 1.2 -> constant time everything
# downgrade attacks

=== What libraries should I use? ===

# Unfortunately SSL/TLS has suffered from many implementation flaws
# the most famous one being heartbleed of course

# BoringSSL (libreSSL?)
# BearSSL
# Everest https://project-everest.github.io/

=== What about DTLS? ===

# A final mention about DTLS, which is just TLS over UDP (instead of TCP)
# It's pretty much the same as TLS, except that some concerns like amplification attacks and IP spoofing have been taken care of by DTLS
# The idea is that DTLS will perform some sort of TCP handshake before doing any crypto/handshake

== What about SSH? ==

# There's not much to say about SSH, besides the fact that you're probably using this in one place and one place only
# that is, when you authenticate to a server
# no real indication to give, besides how the keys should be generated and stored. 
# Depending on your algorithm, you can refer to the different section of this website
# otherwise, check www.keylength.com

== What about IPSEC? ==

# nope, use wireguard if you can

== What about VPNs? ==

# wireguard if you can afford to
# https://openvpn.fox-it.com/
