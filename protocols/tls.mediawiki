To '''encrypt communications between endpoints''', several protocols exist. The most populars being '''TLS''', '''SSH''' and '''IPSEC'''. Each usually being used for different purposes. Yet, many developers will often feel the need to re-invent the wheel and create their own "proprietary" protocol. You've heard the saying "don't roll your own crypto", so you know you should use TLS. If you're not using TLS because you have an excellent reason not to use TLS, you are allowed to consider the <a href="http://noiseprotocol.org/">Noise protocol framework</a>, but keep in mind that even Noise requires you to understand what you're doing.

== TLS ==

While TLS is usually used between browsers and webservers, there are no limitations as to how one can use TLS and to what kind of endpoints are able to use TLS to protect their communications. Because of this initial setting though, TLS is commonly encountered as a protocol that '''authenticates the server only''' and does not care about the client (perhaps the client authenticates later via a password in the application layer). Yet, this does not mean that TLS is limited to this configuration and client authentication (via certificates) as part of the protocol is totally possible.

Note that TLS is sometimes seen deeply integrated with another kind of protocol. For example the QUIC protocol (sometimes refered to as TCP 2.0) has encryption by default thanks to TLS.

=== What Versions should be supported? ===

The design of SSL/TLS has had many broken versions in the past. For this reason, nobody uses SSL anymore (which ended at version 3) and more secure versions of TLS (1.2 and 1.3) are pushed.

<table>
<thead>
<tr class="header">
<th>Version</th>
<th>Secure</th>
<th>Vulnerabilities</th>
</tr>
</thead>
<tbody>
<tr class="even">
<td>SSL 3</td>
<td>no</td>
<td>POODLE, RC4NOMORE</td>
</tr>
<tr class="odd">
<td>TLS 1.0</td>
<td>no</td>
<td>BEAST, RC4NOMORE</td>
</tr>
<tr class="even">
<td>TLS 1.1</td>
<td>yes</td>
<td>/</td>
</tr>
<tr class="odd">
<td>TLS 1.2</td>
<td>yes</td>
<td>/</td>
</tr>
<tr class="even">
<td>TLS 1.3</td>
<td>yes</td>
<td>/</td>
</tr>
</tbody>
</table>

'''Ideally, only TLS 1.1, 1.2 and 1.3 should be supported'''. Hyper ideally, only the last version (TLS 1.3) should be supported.

=== Can TLS 1.0 and 1.1 still be supported? ===

Unfortunately, many clients continue to use older versions and it is sometimes tricky to continue to support them. This leads to the question, can we support older version securely?

Note that if you need to follow strong regulations like the <a href="https://www.pcisecuritystandards.org/">PCI DSS</a>, <a href="https://www.comodo.com/e-commerce/ssl-certificates/tls-1-deprecation.php">Anything under TLS 1.1 has been deprecated</a> which should facilitate this answer.

'''Non-web browser <-> web server setup''' Both <a href="https://www.dfranke.us/posts/2014-10-14-how-poodle-happened.html">POODLE</a> (SSL 3.0) and <a href="https://cryptologie.net/article/413/beast-an-explanation-of-the-cbc-attack-on-tls/">BEAST (TLS 1.0)</a> are attacks that usually imply a browser-based client. This is because the attack has several requirements:

# the attacker needs a way to '''execute malicious code on the client-side''' in order to emite specific SSL/TLS packets (this is usually done by serving malicious javascript to the client)
# each client's encrypted '''packet content is in part known''' (usually true for browsers since we know what HTTP requests look like)
# what we want to steal is '''repeatedly and automatically sent in every requests''' emitted by the client (we are usually targeting a cookie)

For this reason, '''most of the non-browser-webserver scenarios might not be vulnerable to these attacks'''. Nonetheless attacks only get better and one should not rely on a specific scenario to mitigate a powerful attack.

'''Web browser <-> web server setup'''. While SSL 3.0 is pretty much broken and can even endanger secure versions of TLS (<a href="https://drownattack.com/">DROWN</a>), we know ways to <a href="https://cryptologie.net/article/413/beast-an-explanation-of-the-cbc-attack-on-tls/">mitigate the BEAST attack on TLS 1.0</a>. These mitigations are implemented in all modern browsers which let us conclude that <a href="https://blog.qualys.com/ssllabs/2013/09/10/is-beast-still-a-threat">BEAST is no longer a threat</a>. With that in mind, '''supporting TLS 1.0 is possible, but not recommended'''.

=== Can SSL 3.0 still be supported? ===

<a href="https://disablessl3.com/">No. It is completely broken by the POODLE attack and the numerous attacks on RC4.</a>

=== How to support several versions of TLS? ===

The first problem in supporting several versions of TLS is in the certificates presented by the server (and possibly the client). If they are the same accross different versions of TLS, we are doing what is effectively called "key re-use". The next question "Can I re-use a server's private key?" approaches the problems with that.
In addition, clients will often "fallback" to older versions if they cannot connect to more recent versions. This is all done in good faith but can in some cases be induced by malicious man-in-the-middle attackers. This is what we call "downgrade attacks". Fortunately, we have mitigations against these which need to be implemented on both side of the protocol.
On the client-side of things, a fake <a href="">tls_fallback_scsv</a> cipher suite can be sent after doing a fallback to signal to the server what happened. The server can then check if both endpoints indeed support a more recent version of TLS than is being negotiated.
On the server-side of things, TLS 1.3-enabled servers who support lower TLS versions must include a hint that they support TLS 1.3 <a href="https://tools.ietf.org/html/rfc8446#section-4.1.3">in their random value</a>.

Note that these mitigations are "best-effort", if the other side does not implement them they will be ignored.

=== Can I re-use a server's private key? ===

Has research has shown [<a href="https://crypto.stanford.edu/RealWorldCrypto/slides/kenny.pdf">Key Reuse: Theory and Practice, <a href="https://drownattack.com/">DROWN</a>]. Key re-use accross applications and protocols can lead to severe vulnerabilities. For this reason, it is advised to use a server's private key only for the purpose it was designed for.

=== What Cipher Suites are secure? ===

A perfect whitelist of cipher suites would include combinations of the following algorithms:

# key exchange: ECDH
# signature: RSA or ECDSA
# authenticated encryption: AES-128-GCM, AES-256-GCM or Chacha20-Poly1305
# hash: SHA-256, SHA-384 or SHA-521

For example the following cipher suite would be a good candidate <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>.

=== How to read a Ciphersuite? ===

Note that OpenSSL is stupid and has renamed all the ciphersuites. Fortunately the OWASP has a <a href="https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet=Table_of_the_ciphers_.28and_their_priority_from_high_.281.29_to_low_.28e.g._19.29.29">translation table</a>.

Nonetheless, this doesn't mean that other algorithms are not secure.

'''RSA key exchange''' has had a lot of issues with the Bleichenbacher attack. Implementations are expected not to leak any information about the correctness of the decryption, but most of them still fail this test. Hence this mode should be avoided just because attacks against it are really practical and hard to mitigate correctly. In addition, this key exchange does not provide forward secrecy and is one of the reason why it has been removed from TLS 1.3.

'''DH key exchange''' has had <a href="https://eprint.iacr.org/2016/644) (LOGJAM) with bad groups in the past. That is to say if the server use secure groups and renew there should be no issues. You can use the [test_DHparams](https://github.com/mimoo/test_DHparams">issues</a> tool to verify if a server's Diffie-Hellman parameters are fine.

'''DSA''' ?

'''AES-CBC''' is wrongly implemented in TLS and has lead to several practical attacks. POODLE on SSL 3, BEAST on TLS 1.0 and padding oracles on all versions. That is to say, there exist client-side mitigations for BEAST (none server-side) and padding oracles on CBC should not be possible if the implementation does not leak information about the correctness of the decryption. That is, implementations have been found to repeatidly make mistakes there (Lucky Thirteen has been re-discovered many times) and thus AES-CBC should be quickly deprecated.

'''3DES''' also called DES-CBC3 or DES-EDE (for Encryption-Decryption-Encryption) was pointed out by the <a href="https://www.cryptologie.net/article/373/tldr-of-the-sweet32-attack-on-the-practical-in-security-of-64-bit-block-ciphers/) attack as insecure (along with other 64-bit ciphers">sweet32</a>. Although the attack remains highly impractical and hence the algorithm can be used but should be scheduled for deprecation.

'''RC4''' ?

TLS can support many more ciphers through various extensions. It would be too long for us to list why each of them should not be included. Wikipedia has [a useful table](https://en.wikipedia.org/wiki/Transport_Layer_Security=Cipher
) that shows what ciphers are deemed secure or not.

In addition, Mozilla's <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">SSL config generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/?hsts=no) and [Server-side TLS wiki</a> can be used to guide you through generating sane TLS configurations.

Without a server's source code, the most straight forward way to assess its configuration is to scan it via tools. Check the <a href="">scanning a server</a> section.

Note that sometimes, you want to support older clients that do not have better options than RC4 or DSA or etc... In the end, the server is always the one who chooses and can choose the best option provided by the client. The only danger is having the server offer really bad key exchange mechanisms which would allow a MITM attacker to hide the real list of the client to pretend that the client only support weak ciphers (ciphersuite downgrade?). See LOGJAM and FREAK

<blockquote> Similarly, GFEs will prefer RC4 over AES-CBC only for low protocol versions (SSLv3/TLSv1) because negotiating these versions with AES-CBC would leave the clients vulnerable to POODLE. </blockquote>
# https://sites.google.com/site/bughunteruniversity/nonvuln/commonly-reported-ssl-tls-vulnerabilities

=== Is renog a problem in TLS? ===

Probably not, see ekr blog post, but disable it nonetheless

=== What is DER, .pem, ASN.1, x509, base64, etc. ? ===

tktktk

=== Is 0-RTT OK in TLS 1.3? ===

TLS 1.3 introduces a new concept called "0-RTT" or "early data" which allows clients to send encrypted requests to servers during their very first flight of messages. Because of the design of this feature, these messages are not forward-secure and are '''replayable'''. This is a problem if such requests can mutate the state of the server.

TLS 1.3 client that enable this feature are supposed to maintain a whitelist of requests that are safe to send as early data.

TLS 1.3 servers that enable this feature should also maintain such a whitelist ('''REALLY?''')

'''Ideally, 0-RTT should not be enabled on either side of the connection'''.

=== How to assess certificates? ===

# a server is usually authenticated via its certificate
# the certificate contains a public key (see keylength.com)
# the certificate also contains a signature from an authority that you trust
# that's PKI
# otherwise you need to trust the certificate (certificate pinning)
# these certificates are usually stores as <code>.pem</code> files
# <a href="">x509 vs asn.1 vs DER vs pem</a>
# note that x509 parsers are often riddled with bugs (parsing is hard)
    - so might want to look in there for wrong parsing, but it's hard because you need to understand how to parse DER
    - fuzz! you can use frankencerts
    - boringSSL and others might have more corpus
# you can easily analyze a certificate with:

<pre><code>
openssl x509 -in yourcert.pem -noout -text
</code></pre>

# https://github.com/zmap/zlint ?
# https://github.com/briansmith/webpki ?
# https://github.com/square/certstrap

<a href="">check more openssl handies here</a>

# how to store a certificate?
# unicornator helps you looking at certificates as well
# <a href="https://www.cryptologie.net/article/374/common-x509-certificate-validationcreation-pitfalls"></a>

=== How to test a TLS server as a blackbox? ===

The easy way to test a server is to scan it via open source tools like:

# <a href="https://testssl.sh/">testssl</a>
# <a href="https://github.com/nabla-c0d3/sslyze">sslyze</a>
# https://github.com/mozilla/tls-observatory
# https://github.com/mozilla/cipherscan
# https://www.bolet.org/TestSSLServer/
# https://github.com/tomato42/tlsfuzzer

Unfortunately outputs obtained from these tools are often not clear and are sometimes false positives. 

Online scanners like <a href="https://www.ssllabs.com/ssltest/">SSLlabs</a> exist.

The OpenSSL CLI can be used as a client:

<pre><code>$ openssl s_client -connect google.com:443</code></pre>

Socat can also be handful:

<pre><code>$ socat stdio openssl-connect:google.com:443,cert=$HOME/etc/client.pem,cafile=$HOME/etc/server.crt</code></pre>

=== how to test a TLS client as a blackbox? ===

To test TLS clients that are meant to accept any valid certificates, one handy website is <a href="https://badssl.com/">badssl.com</a> which is a collection of webservers serving "bad" certificates. Your client should always refuse these.

Some TLS clients are meant to only accept a set of certificates, for example a mobile application connecting to https://api.mywebsite.com should not accept a server broadcasting valid certificate for https://www.evil.com. To test these you can try to man-the-middle the connection via tools like <a href="https://mitmproxy.org/">mitmproxy</a>.

Furthermore, wireshark can be used to analyze if clients correctly split AES-CBC payloads to mitigate against the BEAST attack.

<img src="https://i.imgur.com/Tyrtb20.png">


=== How to configure a TLS server correctly? ===

To configure Apache / Nginx / Lighttpd / HAProxy / AWS ELB, Mozilla's <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/?hsts=no">SSL config generator</a> is the go-to resource. Mozilla also publishes a <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">server-side TLS set of security consideration</a>.

For language-specific configurations, refer to:

# <a href="https://github.com/gtank/cryptopasta/blob/master/tls_test.go">Go</a>
# ...

=== Tools ===

# https://github.com/RUB-NDS/TLS-Attacker  
# https://github.com/hannob/selftls
# TKTK
# https://github.com/FiloSottile/mkcert ?

=== code review of a TLS implementation ===

# very few people can write a full TLS stack securely
# do not review a TLS implementation unless you have to, it takes more than this guide to do it
# using one of the library advised in the next section is better
# but if you really have to, here are a few pointers:

# x509 parsing
# incorrect state machine
# vaudenay -> padding errors
# lucky thirteen in TLS 1. -> constant time CBC MAC verification
# RSA bleichenbacher in TLS 1. and TLS 1.2 -> constant time everything
# downgrade attacks

=== What libraries should I use? ===

# Unfortunately SSL/TLS has suffered from many implementation flaws
# the most famous one being heartbleed of course

# BearSSL
# BoringSSL (libreSSL?)
# Everest https://project-everest.github.io/

=== What about DTLS? ===

# A final mention about DTLS, which is just TLS over UDP (instead of TCP)
# It's pretty much the same as TLS, except that some concerns like amplification attacks and IP spoofing have been taken care of by DTLS
# The idea is that DTLS will perform some sort of TCP handshake before doing any crypto/handshake

== What about SSH? ==

# There's not much to say about SSH, besides the fact that you're probably using this in one place and one place only
# that is, when you authenticate to a server
# no real indication to give, besides how the keys should be generated and stored. 
# Depending on your algorithm, you can refer to the different section of this website
# otherwise, check www.keylength.com

== What about IPSEC? ==

# nope, use wireguard if you can

== What about VPNs? ==

# wireguard if you can afford to
# https://openvpn.fox-it.com/
